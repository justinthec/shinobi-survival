<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ninja Legends: Chakra Wars</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #menu,
        .hud-bar,
        #notifications {
            pointer-events: auto;
        }

        /* Menu Styling */
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.9)), url('https://www.transparenttextures.com/patterns/cubes.png');
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .char-select {
            display: flex;
            gap: 40px;
            margin-top: 40px;
        }

        .char-card {
            border: 4px solid #444;
            padding: 30px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            background: #2d3748;
            width: 220px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .char-card:hover,
        .char-card.selected {
            transform: scale(1.05);
        }

        .char-card.naruto.selected {
            border-color: #f6ad55;
            box-shadow: 0 0 25px #f6ad55;
        }

        .char-card.sasuke.selected {
            border-color: #63b3ed;
            box-shadow: 0 0 25px #63b3ed;
        }

        /* HUD */
        .hud-bar {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skill-icon {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            background: #222;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transition: border-color 0.2s;
        }

        .skill-icon.ready {
            border-color: #fff;
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            height: 0%;
            transition: height 0.1s linear;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="menu">
            <h1 class="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-orange-400 to-red-600 mb-2 italic tracking-tighter"
                style="text-shadow: 0 0 20px rgba(255,100,0,0.5);">SHINOBI CLASH</h1>
            <p class="text-gray-300 text-xl tracking-widest">CHOOSE YOUR DESTINY</p>

            <input type="text" id="username" placeholder="ENTER NAME" value="Ninja"
                class="mt-8 p-4 rounded bg-gray-800 text-white border-2 border-gray-600 text-center text-xl outline-none focus:border-orange-500 w-64 uppercase font-bold tracking-wider">

            <div class="char-select">
                <div class="char-card naruto selected" onclick="selectChar('naruto')" id="card-naruto">
                    <div
                        class="w-24 h-24 rounded-full bg-gradient-to-br from-orange-400 to-yellow-500 mx-auto mb-4 border-4 border-white shadow-lg flex items-center justify-center text-4xl">
                        ðŸŒ€</div>
                    <h3 class="font-bold text-2xl text-orange-400 uppercase">Naruto</h3>
                    <p class="text-xs text-gray-400 mt-2 uppercase tracking-wide">Wind Style</p>
                    <div class="mt-4 text-left text-sm text-gray-300 space-y-2">
                        <div class="flex items-center gap-2"><span class="bg-gray-700 px-1 rounded text-xs">Q</span>
                            Rasen Shuriken</div>
                        <div class="flex items-center gap-2"><span class="bg-gray-700 px-1 rounded text-xs">E</span>
                            Clone Barrage</div>
                    </div>
                </div>
                <div class="char-card sasuke" onclick="selectChar('sasuke')" id="card-sasuke">
                    <div
                        class="w-24 h-24 rounded-full bg-gradient-to-br from-blue-600 to-purple-700 mx-auto mb-4 border-4 border-white shadow-lg flex items-center justify-center text-4xl">
                        âš¡</div>
                    <h3 class="font-bold text-2xl text-blue-400 uppercase">Sasuke</h3>
                    <p class="text-xs text-gray-400 mt-2 uppercase tracking-wide">Lightning Style</p>
                    <div class="mt-4 text-left text-sm text-gray-300 space-y-2">
                        <div class="flex items-center gap-2"><span class="bg-gray-700 px-1 rounded text-xs">Q</span>
                            Fireball Jutsu</div>
                        <div class="flex items-center gap-2"><span class="bg-gray-700 px-1 rounded text-xs">E</span>
                            Amaterasu</div>
                    </div>
                </div>
            </div>

            <button onclick="startGame()"
                class="mt-12 px-10 py-4 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-500 hover:to-red-600 rounded-lg font-black text-2xl uppercase tracking-widest shadow-lg transform transition hover:scale-105 active:scale-95">Start
                Fight</button>
        </div>

        <div id="hud" class="hidden absolute bottom-8 left-1/2 transform -translate-x-1/2 flex gap-6 hud-bar">
            <div class="text-center group">
                <div class="skill-icon" id="skill-q">
                    <span class="z-10 group-hover:scale-110 transition">Q</span>
                    <div class="cooldown-overlay" id="cd-q"></div>
                </div>
                <span class="text-[10px] text-gray-400 font-bold uppercase mt-1 tracking-wider">Skill 1</span>
            </div>
            <div class="text-center group">
                <div class="skill-icon" id="skill-e">
                    <span class="z-10 group-hover:scale-110 transition">E</span>
                    <div class="cooldown-overlay" id="cd-e"></div>
                </div>
                <span class="text-[10px] text-gray-400 font-bold uppercase mt-1 tracking-wider">Skill 2</span>
            </div>
            <div class="text-center group">
                <div class="skill-icon" id="skill-sp">
                    <span class="z-10 group-hover:scale-110 transition text-sm">SPC</span>
                    <div class="cooldown-overlay" id="cd-sp"></div>
                </div>
                <span class="text-[10px] text-gray-400 font-bold uppercase mt-1 tracking-wider">Dash</span>
            </div>
        </div>

        <div id="notifications"></div>
    </div>

    <script>
        // --- Game Constants & Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameActive = false;

        // Settings
        const MAP_SIZE = 1600;
        const CAM_SMOOTH = 0.1;

        // Game State
        const players = {};
        let projectiles = [];
        let particles = [];
        let combatTexts = [];
        let cameraX = 0, cameraY = 0;

        // Inputs
        const keys = { w: false, a: false, s: false, d: false };
        const mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };

        // Config
        let myId = 'player';
        let enemyId = 'cpu';
        let selectedChar = 'naruto';

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Improved Sprites & Visuals ---

        function drawNinja(p) {
            ctx.save();
            ctx.translate(p.x, p.y);

            // --- State Calculations ---
            const isMoving = p.state === 'moving';
            const runAnim = isMoving ? Math.sin(Date.now() / 80) : 0; // Faster running cycle
            const breathAnim = Math.sin(Date.now() / 400) * 0.5;

            // Rotate entire character to face direction (Top Down logic)
            // 0 radians = Facing Right.
            ctx.rotate(p.angle);

            // Dash Ghost Effect
            if (p.dash && p.dash.active) {
                ctx.globalAlpha = 0.6;
            }

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(-2, 2, 16, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- PALETTES ---
            const narutoColors = {
                skin: '#ffcba4', hair: '#ffdd00', orange: '#ff6600', black: '#1a1a1a',
                blue: '#0055aa', metal: '#dddddd', swirl: '#cc0000'
            };
            const sasukeColors = {
                skin: '#ffe0bd', hair: '#111122', grey: '#9ca3af', darkGrey: '#4b5563',
                rope: '#8b5cf6', blue: '#1e3a8a'
            };

            const c = p.type === 'naruto' ? narutoColors : sasukeColors;

            // --- DRAW BODY (Shoulders/Torso) ---
            if (p.type === 'naruto') {
                // Jacket Base
                ctx.fillStyle = c.orange;
                ctx.beginPath(); ctx.ellipse(-5, 0, 16, 12, 0, 0, Math.PI * 2); ctx.fill();
                // Black Shoulder Swirls area
                ctx.fillStyle = c.black;
                ctx.beginPath(); ctx.arc(0, -6, 8, 0, Math.PI * 2); ctx.fill(); // Left shoulder
                ctx.beginPath(); ctx.arc(0, 6, 8, 0, Math.PI * 2); ctx.fill();  // Right shoulder
                // Collar
                ctx.fillStyle = c.orange;
                ctx.strokeStyle = c.black; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.roundRect(-4, -8, 8, 16, 4); ctx.fill(); ctx.stroke();
            } else {
                // Sasuke Shirt
                ctx.fillStyle = c.grey;
                ctx.beginPath(); ctx.ellipse(-5, 0, 16, 12, 0, 0, Math.PI * 2); ctx.fill();
                // Rope Belt (Visible at back)
                ctx.fillStyle = c.rope;
                ctx.beginPath(); ctx.roundRect(-14, -8, 4, 16, 2); ctx.fill();
                // High Collar (Fan shape behind head)
                ctx.fillStyle = c.blue;
                ctx.beginPath();
                ctx.moveTo(0, -10); ctx.lineTo(10, -14); ctx.lineTo(10, 14); ctx.lineTo(0, 10);
                ctx.fill();
            }

            // --- LEGS (Running Animation) ---
            // In top down, legs are just small shapes peaking out, often scissoring
            ctx.fillStyle = c.black; // Pants usually dark
            if (isMoving) {
                // Left Leg
                ctx.beginPath(); ctx.ellipse(-10 + runAnim * 6, -8, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
                // Right Leg
                ctx.beginPath(); ctx.ellipse(-10 - runAnim * 6, 8, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
            }

            // --- ARMS (Naruto Run Style) ---
            // Arms trail behind
            if (isMoving && !p.casting) {
                // Trailing arms
                ctx.fillStyle = p.type === 'naruto' ? c.orange : c.grey;
                // Left Arm
                ctx.save();
                ctx.translate(-10, -12); ctx.rotate(-0.4 + runAnim * 0.2);
                ctx.beginPath(); ctx.roundRect(-10, -3, 20, 6, 3); ctx.fill();
                // Hand
                ctx.fillStyle = c.skin;
                ctx.beginPath(); ctx.arc(-10, 0, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                // Right Arm
                ctx.save();
                ctx.translate(-10, 12); ctx.rotate(0.4 - runAnim * 0.2);
                ctx.beginPath(); ctx.roundRect(-10, -3, 20, 6, 3); ctx.fill();
                // Hand
                ctx.fillStyle = c.skin;
                ctx.beginPath(); ctx.arc(-10, 0, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            } else {
                // Idle / Combat Stance (Arms forward/side)
                ctx.fillStyle = p.type === 'naruto' ? c.orange : c.grey;
                // Left Arm
                ctx.beginPath(); ctx.roundRect(0, -16, 12, 6, 3); ctx.fill();
                // Right Arm
                ctx.beginPath(); ctx.roundRect(0, 10, 12, 6, 3); ctx.fill();
                // Hands
                ctx.fillStyle = c.skin;
                ctx.beginPath(); ctx.arc(12, -13, 4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(12, 13, 4, 0, Math.PI * 2); ctx.fill();
            }

            // --- HEAD ---
            ctx.fillStyle = c.skin;
            // Draw head slightly offset for "neck" logic
            ctx.beginPath(); ctx.arc(2, 0, 11, 0, Math.PI * 2); ctx.fill();

            // --- HAIR (The most important part) ---
            if (p.type === 'naruto') {
                // Headband (Forehead)
                ctx.fillStyle = c.blue;
                ctx.fillRect(8, -10, 4, 20); // Band
                ctx.fillStyle = c.metal;
                ctx.fillRect(9, -6, 4, 12); // Plate

                // Headband Knot (Trailing behind)
                ctx.save();
                const knotSway = Math.sin(Date.now() / 100) * 0.3;
                ctx.translate(-8, 0); ctx.rotate(knotSway);
                ctx.fillStyle = c.blue;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-12, -4); ctx.lineTo(-12, 4); ctx.fill();
                ctx.restore();

                // Spiky Yellow Hair (Sunburst)
                ctx.fillStyle = c.hair;
                ctx.beginPath();
                for (let i = 0; i < 14; i++) {
                    // Spikes radiating from center of head
                    const angle = (i / 14) * Math.PI * 2;
                    const isFront = Math.cos(angle) > 0; // Face area

                    // Shorter spikes in front to show headband
                    const len = isFront ? 12 : 16;
                    const cx = 2 + Math.cos(angle) * len;
                    const cy = Math.sin(angle) * len;

                    // Bezier for softer spikes
                    const cp1x = 2 + Math.cos(angle - 0.2) * (len * 0.6);
                    const cp1y = Math.sin(angle - 0.2) * (len * 0.6);

                    if (i === 0) ctx.moveTo(cx, cy);
                    else ctx.quadraticCurveTo(cp1x, cp1y, cx, cy);
                }
                ctx.closePath();
                ctx.fill();

            } else {
                // Sasuke Hair (Duck butt style)
                ctx.fillStyle = c.hair;

                // Back Spikes (The Duck Butt)
                ctx.beginPath();
                ctx.moveTo(-5, 0);
                ctx.lineTo(-18, -10); ctx.lineTo(-12, -2); // Top spike
                ctx.lineTo(-20, 5); ctx.lineTo(-12, 6);  // Mid spike
                ctx.lineTo(-16, 15); ctx.lineTo(-6, 8);   // Bot spike
                ctx.fill();

                // Top/Side Bangs framing face
                ctx.beginPath();
                ctx.arc(2, 0, 12, Math.PI * 0.5, Math.PI * 1.5); // Back of head base
                // Bangs
                ctx.lineTo(8, -8); ctx.lineTo(4, -4);
                ctx.lineTo(8, 8); ctx.lineTo(2, 11);
                ctx.fill();

                // Forehead protector usually hidden or worn, let's skip for casual Sasuke look
                // Or add headband on forehead
                ctx.fillStyle = c.blue;
                ctx.fillRect(8, -9, 3, 18);
                ctx.fillStyle = c.metal;
                ctx.fillRect(9, -5, 3, 10);
            }

            // Restore global alpha
            ctx.globalAlpha = 1.0;
            ctx.restore();

            // HP Bar
            drawHealthBar(p);
        }

        function drawHealthBar(p) {
            ctx.save();
            ctx.translate(p.x, p.y - 50);
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.beginPath(); ctx.roundRect(-30, 0, 60, 8, 4); ctx.fill();
            const pct = Math.max(0, p.hp / p.maxHp);
            ctx.fillStyle = pct > 0.5 ? '#48bb78' : '#f56565';
            ctx.beginPath(); ctx.roundRect(-28, 2, 56 * pct, 4, 2); ctx.fill();

            // Name
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
            ctx.fillText(p.name, 0, -5);
            ctx.restore();
        }

        // --- Logic ---

        function startGame() {
            const name = document.getElementById('username').value || "Ninja";

            players[myId] = createPlayer(myId, name, selectedChar, 200, MAP_SIZE / 2);
            // Enemy is opposite
            const enemyType = selectedChar === 'naruto' ? 'sasuke' : 'naruto';
            players[enemyId] = createPlayer(enemyId, "Rogue Ninja", enemyType, MAP_SIZE - 200, MAP_SIZE / 2);
            players[enemyId].isAI = true;

            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').classList.remove('hidden');
            gameActive = true;
            requestAnimationFrame(gameLoop);
        }

        function createPlayer(id, name, type, x, y) {
            return {
                id, name, type, x, y,
                hp: 100, maxHp: 100,
                angle: 0,
                state: 'idle',
                cooldowns: { q: 0, e: 0, sp: 0 },
                dash: { active: false, vx: 0, vy: 0, life: 0 },
                stats: type === 'naruto' ? { speed: 6 } : { speed: 6.5 }
            };
        }

        function selectChar(type) {
            selectedChar = type;
            document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`card-${type}`).classList.add('selected');
        }

        // --- Combat System ---

        function castSpell(player, key, mx, my) {
            const cd = player.cooldowns;
            const angle = Math.atan2(my - player.y, mx - player.x);

            // Global Cooldown check (small)
            if (player.casting) return;

            if (key === 'q' && cd.q <= 0) {
                cd.q = 2000; // 2s CD

                if (player.type === 'naruto') {
                    // Rasen Shuriken
                    spawnProjectile(player, 'rasenshuriken', angle);
                    player.casting = 10; // Animation lock frames
                } else {
                    // Fireball Jutsu
                    spawnProjectile(player, 'fireball', angle);
                    player.casting = 10;
                }
            } else if (key === 'e' && cd.e <= 0) {
                cd.e = 6000; // 6s CD

                if (player.type === 'naruto') {
                    // Clone Strike (Teleport Clone)
                    // Visual: Smoke at target
                    createExplosion(mx, my, 'smoke', 10);
                    // Spawn a temporary clone projectile that exists for longer so it's visible
                    projectiles.push({
                        type: 'clone_strike', x: mx, y: my,
                        owner: player.id, life: 30, radius: 40,
                        angle: angle
                    });
                } else {
                    // Amaterasu (Delayed AOE at cursor)
                    // Spawn invisible marker first
                    projectiles.push({
                        type: 'amaterasu_buildup', x: mx, y: my,
                        owner: player.id, life: 40, radius: 50
                    });
                }
            } else if (key === ' ' && cd.sp <= 0) {
                // Dash (Body Flicker)
                cd.sp = 3000;
                createExplosion(player.x, player.y, 'smoke', 3);

                const dashSpeed = 25;
                player.dash = {
                    active: true,
                    life: 8, // frames of dash
                    vx: Math.cos(angle) * dashSpeed,
                    vy: Math.sin(angle) * dashSpeed
                };
            }

            updateHud(player);
        }

        function spawnProjectile(owner, type, angle) {
            const speed = type === 'fireball' ? 14 : 18; // Rasenshuriken fast
            const life = type === 'fireball' ? 50 : 60;

            projectiles.push({
                type: type,
                x: owner.x + Math.cos(angle) * 30,
                y: owner.y + Math.sin(angle) * 30,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                owner: owner.id,
                angle: angle,
                life: life,
                maxLife: life,
                radius: type === 'fireball' ? 20 : 25,
                state: 'flying' // or 'exploding'
            });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                if (p.type === 'amaterasu_buildup') {
                    p.life--;
                    // Draw warning circle logic in render
                    if (p.life <= 0) {
                        // Explode into real damage
                        projectiles.push({
                            type: 'amaterasu_burn', x: p.x, y: p.y,
                            owner: p.owner, life: 60, radius: 60, isAoe: true
                        });
                        projectiles.splice(i, 1);
                    }
                    continue;
                }

                if (p.state === 'exploding' || p.isAoe) {
                    // Stationary damaging zone
                    p.life--;
                    if (p.life % 5 === 0) { // Tick damage
                        checkCollisions(p);
                    }
                    if (p.life <= 0) projectiles.splice(i, 1);
                    continue;
                }

                // Moving Projectiles (or clone stationary)
                if (p.type !== 'clone_strike') {
                    p.x += p.vx;
                    p.y += p.vy;
                }
                p.life--;

                // Trails
                if (p.type === 'fireball') createParticle(p.x, p.y, 'orange', 1);
                if (p.type === 'rasenshuriken') createParticle(p.x, p.y, 'cyan', 1);

                // Collision
                let hit = checkCollisions(p);

                // End of life expansion
                if (hit || p.life <= 0) {
                    if (p.type === 'rasenshuriken') {
                        // Expand
                        p.state = 'exploding';
                        p.life = 40; // Duration of dome
                        p.radius = 80; // Huge
                        p.vx = 0; p.vy = 0;
                        createExplosion(p.x, p.y, 'cyan', 20);
                    } else if (p.type === 'fireball') {
                        p.state = 'exploding';
                        p.life = 10;
                        p.radius = 50;
                        p.vx = 0; p.vy = 0;
                        createExplosion(p.x, p.y, 'orange', 20);
                    } else if (p.type === 'clone_strike') {
                        projectiles.splice(i, 1);
                    } else {
                        projectiles.splice(i, 1);
                    }
                }
            }
        }

        function checkCollisions(proj) {
            let hitSomething = false;
            Object.values(players).forEach(target => {
                if (target.id === proj.owner) return;

                const dist = Math.hypot(target.x - proj.x, target.y - proj.y);
                if (dist < proj.radius + 20) {
                    hitSomething = true;
                    // Damage
                    let dmg = 0;
                    if (proj.type === 'fireball') dmg = 15;
                    if (proj.type === 'rasenshuriken') dmg = 5; // Multi-tick
                    if (proj.type === 'clone_strike') dmg = 20;
                    if (proj.type === 'amaterasu_burn') dmg = 2; // Fast tick
                    if (proj.state === 'exploding') dmg = 2; // Tick dmg

                    if (dmg > 0) {
                        target.hp -= dmg;
                        createDamageText(target.x, target.y, dmg);
                        createParticle(target.x, target.y, 'red', 3);
                    }
                }
            });
            return hitSomething;
        }

        // --- Render Loop ---

        function render() {
            // Bg
            ctx.fillStyle = '#1a202c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 2;
            const grid = 100;
            const startX = Math.floor(cameraX / grid) * grid;
            const startY = Math.floor(cameraY / grid) * grid;
            for (let x = startX; x < cameraX + canvas.width; x += grid) {
                ctx.beginPath(); ctx.moveTo(x, cameraY); ctx.lineTo(x, cameraY + canvas.height); ctx.stroke();
            }
            for (let y = startY; y < cameraY + canvas.height; y += grid) {
                ctx.beginPath(); ctx.moveTo(cameraX, y); ctx.lineTo(cameraX + canvas.width, y); ctx.stroke();
            }

            // Map Border
            ctx.strokeStyle = '#e53e3e';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, MAP_SIZE, MAP_SIZE);

            // Objects
            drawParticles();

            // Projectiles
            projectiles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);

                if (p.type === 'fireball') {
                    if (p.state === 'flying') {
                        // Core
                        ctx.fillStyle = '#ed8936';
                        ctx.shadowColor = '#f6ad55'; ctx.shadowBlur = 20;
                        ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(-5, -5, p.radius * 0.5, 0, Math.PI * 2); ctx.fill();
                    } else {
                        // Explosion
                        ctx.fillStyle = 'rgba(237, 137, 54, 0.5)';
                        ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2); ctx.fill();
                    }
                } else if (p.type === 'rasenshuriken') {
                    ctx.shadowColor = '#4fd1c5'; ctx.shadowBlur = 15;
                    ctx.rotate(Date.now() / 50); // Spin

                    if (p.state === 'flying') {
                        ctx.fillStyle = '#4fd1c5'; // Core
                        ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                        // Blades
                        ctx.fillStyle = 'rgba(255,255,255,0.8)';
                        for (let i = 0; i < 4; i++) {
                            ctx.rotate(Math.PI / 2);
                            ctx.beginPath(); ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(20, -10, 40, 0);
                            ctx.quadraticCurveTo(20, 10, 0, 0);
                            ctx.fill();
                        }
                    } else {
                        // Dome expansion
                        ctx.fillStyle = 'rgba(79, 209, 197, 0.3)';
                        ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2); ctx.fill();
                        // Swirls
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(0, 0, p.radius * 0.8, 0, Math.PI * 2); ctx.stroke();
                    }
                } else if (p.type === 'amaterasu_buildup') {
                    // Warning circle
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.setLineDash([]);
                } else if (p.type === 'amaterasu_burn') {
                    // Black Flames
                    ctx.fillStyle = 'black';
                    ctx.shadowColor = 'purple'; ctx.shadowBlur = 10;
                    for (let i = 0; i < 5; i++) {
                        const s = p.radius * Math.random();
                        const ang = Math.random() * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(ang) * 20, Math.sin(ang) * 20, s, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (p.type === 'clone_strike') {
                    // Draw a quick clone - Manually replicating body drawing logic
                    ctx.globalAlpha = 0.8;

                    // Rotate towards aim
                    ctx.rotate(p.angle);

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath(); ctx.ellipse(0, 5, 20, 20, 0, 0, Math.PI * 2); ctx.fill();

                    const c = { skin: '#ffcba4', hair: '#ffdd00', orange: '#ff6600', black: '#1a1a1a', blue: '#0055aa', metal: '#dddddd' };

                    // Jacket Base (Simple clone draw)
                    ctx.fillStyle = c.orange; ctx.beginPath(); ctx.ellipse(-5, 0, 16, 12, 0, 0, Math.PI * 2); ctx.fill();
                    // Head
                    ctx.fillStyle = c.skin; ctx.beginPath(); ctx.arc(2, 0, 11, 0, Math.PI * 2); ctx.fill();
                    // Hair
                    ctx.fillStyle = c.hair; ctx.beginPath();
                    for (let i = 0; i < 14; i++) {
                        const angle = (i / 14) * Math.PI * 2; const len = 16;
                        const cx = 2 + Math.cos(angle) * len; const cy = Math.sin(angle) * len;
                        if (i === 0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
                    }
                    ctx.fill();

                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            });

            // Players
            Object.values(players).sort((a, b) => a.y - b.y).forEach(p => drawNinja(p));

            // Combat Text
            combatTexts.forEach(t => {
                ctx.fillStyle = t.color || 'white';
                ctx.font = "bold 24px Arial";
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(t.val, t.x, t.y);
                ctx.fillText(t.val, t.x, t.y);
            });

            ctx.restore();
        }

        // --- Core Loop ---

        function update() {
            if (!gameActive) return;

            // 1. Update Me
            const me = players[myId];
            if (me) {
                // Dash Physics Override
                if (me.dash && me.dash.active) {
                    me.x += me.dash.vx;
                    me.y += me.dash.vy;
                    me.dash.life--;
                    createParticle(me.x, me.y, 'rgba(255,255,255,0.5)', 4); // Trail
                    if (me.dash.life <= 0) me.dash.active = false;
                } else {
                    // Normal Movement
                    let dx = 0, dy = 0;
                    if (keys.w) dy--; if (keys.s) dy++;
                    if (keys.a) dx--; if (keys.d) dx++;

                    if (dx !== 0 || dy !== 0) {
                        const l = Math.hypot(dx, dy);
                        me.x += (dx / l) * me.stats.speed;
                        me.y += (dy / l) * me.stats.speed;
                        me.state = 'moving';
                    } else {
                        me.state = 'idle';
                    }
                }

                me.angle = Math.atan2(mouse.worldY - me.y, mouse.worldX - me.x);

                // Bounds
                me.x = Math.max(0, Math.min(MAP_SIZE, me.x));
                me.y = Math.max(0, Math.min(MAP_SIZE, me.y));

                // Camera
                cameraX += (me.x - canvas.width / 2 - cameraX) * CAM_SMOOTH;
                cameraY += (me.y - canvas.height / 2 - cameraY) * CAM_SMOOTH;

                // Cooldowns
                if (me.cooldowns.q > 0) me.cooldowns.q -= 16;
                if (me.cooldowns.e > 0) me.cooldowns.e -= 16;
                if (me.cooldowns.sp > 0) me.cooldowns.sp -= 16;
                if (me.casting > 0) me.casting--;
            }

            // 2. Update AI
            const ai = players[enemyId];
            if (ai && me) {
                const dist = Math.hypot(me.x - ai.x, me.y - ai.y);
                const angleToMe = Math.atan2(me.y - ai.y, me.x - ai.x);
                ai.angle = angleToMe;

                // Dash Physics Override (AI)
                if (ai.dash && ai.dash.active) {
                    ai.x += ai.dash.vx;
                    ai.y += ai.dash.vy;
                    ai.dash.life--;
                    createParticle(ai.x, ai.y, 'rgba(255,255,255,0.5)', 4);
                    if (ai.dash.life <= 0) ai.dash.active = false;
                } else {
                    // AI Logic
                    if (dist > 400) {
                        ai.x += Math.cos(angleToMe) * ai.stats.speed * 0.9;
                        ai.y += Math.sin(angleToMe) * ai.stats.speed * 0.9;
                        ai.state = 'moving';
                    } else if (dist < 200) {
                        ai.x -= Math.cos(angleToMe) * 2;
                        ai.y -= Math.sin(angleToMe) * 2;
                        ai.state = 'moving';
                    } else {
                        ai.state = 'idle';
                    }
                }

                // AI Cooldowns
                if (ai.cooldowns.q > 0) ai.cooldowns.q -= 16;
                if (ai.cooldowns.e > 0) ai.cooldowns.e -= 16;
                if (ai.cooldowns.sp > 0) ai.cooldowns.sp -= 16;

                // AI Attack
                if (ai.cooldowns.q <= 0 && dist < 700) {
                    // Fire Q
                    castSpell(ai, 'q', me.x, me.y);
                }

                // AI Dodge Logic (if close and cooldown ready)
                if (dist < 150 && ai.cooldowns.sp <= 0 && Math.random() < 0.05) {
                    // Dash away
                    const awayAngle = angleToMe + Math.PI;
                    castSpell(ai, ' ', ai.x + Math.cos(awayAngle) * 200, ai.y + Math.sin(awayAngle) * 200);
                }
            }

            // 3. Update World
            updateProjectiles();
            updateParticles();

            combatTexts = combatTexts.filter(t => t.life > 0);
            combatTexts.forEach(t => { t.y -= 1; t.life--; });
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // --- Helpers ---
        function createExplosion(x, y, type, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                    life: 30 + Math.random() * 20,
                    color: type === 'smoke' ? '#a0aec0' : (type === 'log' ? '#744210' : type),
                    size: Math.random() * 8
                });
            }
        }
        function createParticle(x, y, color, size) {
            particles.push({
                x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                life: 15, color, size
            });
        }
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        function createDamageText(x, y, val) {
            combatTexts.push({ x, y, val, life: 60, color: '#fc8181' });
        }
        function updateHud(p) {
            document.getElementById('cd-q').style.height = (p.cooldowns.q > 0 ? (p.cooldowns.q / 2000) * 100 : 0) + "%";
            document.getElementById('cd-e').style.height = (p.cooldowns.e > 0 ? (p.cooldowns.e / 6000) * 100 : 0) + "%";
            document.getElementById('cd-sp').style.height = (p.cooldowns.sp > 0 ? (p.cooldowns.sp / 5000) * 100 : 0) + "%";

            // Toggle icons
            document.getElementById('skill-q').classList.toggle('ready', p.cooldowns.q <= 0);
            document.getElementById('skill-e').classList.toggle('ready', p.cooldowns.e <= 0);
        }

        // Input Listeners
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.worldX = mouse.x + cameraX;
            mouse.worldY = mouse.y + cameraY;
        });
        window.addEventListener('mousedown', () => {
            // Basic attack placeholder or click to cast?
            // Let's stick to keys for skills.
        });
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (['q', 'e', ' '].includes(k) && gameActive) {
                castSpell(players[myId], k, mouse.worldX, mouse.worldY);
            }
        });

    </script>
</body>

</html>